<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>NEON DRIFT: The Grid</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: 'Courier New', Courier, monospace; }
        
        /* UI Overlay */
        #ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; display: flex; flex-direction: column; justify-content: space-between;
        }

        /* HUD */
        #hud {
            padding: 20px; color: #00ffff; text-shadow: 0 0 10px #00ffff;
            display: flex; justify-content: space-between; font-size: 24px; font-weight: bold;
            animation: pulse 2s infinite;
        }
        
        /* Speedometer */
        .hud-item span { font-size: 40px; }
        .label { font-size: 14px; opacity: 0.7; }

        /* Start Screen */
        #start-screen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.85); z-index: 10;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            pointer-events: auto; backdrop-filter: blur(5px);
        }
        h1 { color: #fff; text-shadow: 0 0 20px #00ffff, 0 0 40px #00ffff; font-size: 60px; margin: 0 0 20px 0; font-style: italic; letter-spacing: 5px; text-transform: uppercase;}
        button {
            background: transparent; border: 2px solid #00ffff; color: #00ffff;
            padding: 15px 40px; font-size: 20px; cursor: pointer;
            text-transform: uppercase; letter-spacing: 2px;
            box-shadow: 0 0 15px #00ffff inset, 0 0 20px #00ffff;
            transition: 0.3s; font-family: inherit;
        }
        button:hover { background: #00ffff; color: #000; box-shadow: 0 0 30px #00ffff inset, 0 0 50px #00ffff; }

        /* Mobile Controls */
        #zone_joystick {
            position: absolute; bottom: 50px; left: 50px; width: 150px; height: 150px;
            z-index: 5; pointer-events: auto; display: none; /* Hidden on desktop by default logic */
        }

        /* Animations */
        @keyframes pulse {
            0% { opacity: 0.8; }
            50% { opacity: 1; text-shadow: 0 0 20px #00ffff; }
            100% { opacity: 0.8; }
        }
        
        #boost-msg {
            position: absolute; top: 40%; left: 50%; transform: translate(-50%, -50%);
            color: #ff00ff; font-size: 40px; font-weight: bold; display: none;
            text-shadow: 0 0 20px #ff00ff;
        }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/nipplejs/0.10.1/nipple.min.js"></script>
</head>
<body>

    <div id="canvas-container"></div>

    <div id="ui-layer">
        <div id="hud">
            <div class="hud-item">
                <div class="label">SPEED</div>
                <span id="speed-display">0</span> <small>KM/H</small>
            </div>
            <div class="hud-item" style="text-align: right; color: #ff00ff; text-shadow: 0 0 10px #ff00ff;">
                <div class="label">SYSTEM</div>
                ONLINE
            </div>
        </div>
        <div id="boost-msg">SPEED BOOST</div>
        <div id="zone_joystick"></div>
    </div>

    <div id="start-screen">
        <h1>NEON GRID</h1>
        <p style="color:#ccc; margin-bottom: 30px;">ARROWS to Drive / Joystick on Mobile</p>
        <button id="start-btn">INITIALIZE</button>
    </div>

    <script type="module">
        import * as THREE from 'https://unpkg.com/three@0.160.0/build/three.module.js';
        import { EffectComposer } from 'https://unpkg.com/three@0.160.0/examples/jsm/postprocessing/EffectComposer.js';
        import { RenderPass } from 'https://unpkg.com/three@0.160.0/examples/jsm/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'https://unpkg.com/three@0.160.0/examples/jsm/postprocessing/UnrealBloomPass.js';

        // --- Configuration ---
        const CONFIG = {
            color: 0x00ffff,
            trailColor: 0x00aaaa,
            boostColor: 0xff00ff,
            gridColor: 0x222222,
            gridGlow: 0x440044,
            maxSpeed: 2.5,
            boostSpeed: 4.5,
            acceleration: 0.05,
            friction: 0.96,
            turnSpeed: 0.06,
            driftFactor: 0.93 // Lower = more slippery
        };

        // --- Audio System (Synthesized) ---
        class SynthAudio {
            constructor() {
                this.ctx = new (window.AudioContext || window.webkitAudioContext)();
                this.engineOsc = null;
                this.engineGain = null;
                this.isMuted = false;
            }

            init() {
                // Engine Sound
                this.engineOsc = this.ctx.createOscillator();
                this.engineOsc.type = 'sawtooth';
                this.engineGain = this.ctx.createGain();
                this.engineGain.gain.value = 0;
                
                // Lowpass filter to muffule the harsh sawtooth
                const filter = this.ctx.createBiquadFilter();
                filter.type = 'lowpass';
                filter.frequency.value = 400;

                this.engineOsc.connect(filter);
                filter.connect(this.engineGain);
                this.engineGain.connect(this.ctx.destination);
                this.engineOsc.start();
            }

            updateEngine(speedRatio) {
                if (!this.engineOsc) return;
                // Pitch rises with speed
                const baseFreq = 60;
                this.engineOsc.frequency.setTargetAtTime(baseFreq + (speedRatio * 200), this.ctx.currentTime, 0.1);
                // Volume rises with speed
                this.engineGain.gain.setTargetAtTime(0.05 + (speedRatio * 0.1), this.ctx.currentTime, 0.1);
            }

            playBoost() {
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.type = 'square';
                osc.frequency.setValueAtTime(200, this.ctx.currentTime);
                osc.frequency.exponentialRampToValueAtTime(800, this.ctx.currentTime + 0.5);
                gain.gain.setValueAtTime(0.1, this.ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + 0.5);
                
                osc.connect(gain);
                gain.connect(this.ctx.destination);
                osc.start();
                osc.stop(this.ctx.currentTime + 0.5);
            }
        }

        // --- Game State ---
        let scene, camera, renderer, composer;
        let player, trailMesh;
        let speedPads = [];
        let trailPoints = [];
        const MAX_TRAIL_LENGTH = 80;
        
        let velocity = new THREE.Vector3();
        let currentSpeed = 0;
        let input = { x: 0, y: 0 }; // x = steering, y = throttle
        let isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
        
        const audio = new SynthAudio();
        const hudSpeed = document.getElementById('speed-display');
        const boostMsg = document.getElementById('boost-msg');

        // --- Init ---
        function init() {
            // Scene Setup
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x000000, 0.002);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 5, -10);

            renderer = new THREE.WebGLRenderer({ antialias: false });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); // Perf optimization
            document.getElementById('canvas-container').appendChild(renderer.domElement);

            // Post Processing (BLOOM)
            const renderScene = new RenderPass(scene, camera);
            const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
            bloomPass.threshold = 0;
            bloomPass.strength = 1.8; // High glow
            bloomPass.radius = 0.5;

            composer = new EffectComposer(renderer);
            composer.addPass(renderScene);
            composer.addPass(bloomPass);

            // Environment
            createGrid();
            createPlayer();
            createTrail();
            
            // Random Speed Pads
            for(let i=0; i<15; i++) {
                createSpeedPad();
            }

            // Inputs
            setupInputs();

            // Resize Handler
            window.addEventListener('resize', onWindowResize, false);
            
            // Start Loop
            requestAnimationFrame(animate);
        }

        function createGrid() {
            // Main floor grid
            const gridHelper = new THREE.GridHelper(2000, 200, CONFIG.gridGlow, CONFIG.gridColor);
            scene.add(gridHelper);

            // Infinite Floor Plane (Invisible, for reflections if we added them, but mainly to hide "below")
            const planeGeometry = new THREE.PlaneGeometry(2000, 2000);
            const planeMaterial = new THREE.MeshBasicMaterial({ color: 0x050505 });
            const plane = new THREE.Mesh(planeGeometry, planeMaterial);
            plane.rotation.x = -Math.PI / 2;
            plane.position.y = -0.1;
            scene.add(plane);
        }

        function createPlayer() {
            player = new THREE.Group();

            // Chassis
            const bodyGeo = new THREE.BoxGeometry(1, 0.5, 2.5);
            const bodyMat = new THREE.MeshBasicMaterial({ color: 0x000000 }); // Black core
            const body = new THREE.Mesh(bodyGeo, bodyMat);
            
            // Glowing Edges/Shell
            const shellGeo = new THREE.BoxGeometry(1.05, 0.55, 2.55);
            const shellMat = new THREE.MeshBasicMaterial({ color: CONFIG.color, wireframe: true });
            const shell = new THREE.Mesh(shellGeo, shellMat);

            // Rear Wheel (Light Block)
            const wheelGeo = new THREE.CylinderGeometry(0.4, 0.4, 0.8, 16);
            wheelGeo.rotateZ(Math.PI / 2);
            const wheelMat = new THREE.MeshBasicMaterial({ color: CONFIG.color });
            const rearWheel = new THREE.Mesh(wheelGeo, wheelMat);
            rearWheel.position.set(0, -0.1, -1);

            // Front Wheel
            const frontWheel = rearWheel.clone();
            frontWheel.position.set(0, -0.1, 1);

            player.add(body);
            player.add(shell);
            player.add(rearWheel);
            player.add(frontWheel);
            player.position.y = 0.5;
            
            scene.add(player);
        }

        function createTrail() {
            // Using a strip for a wall-like trail
            // Initialize with dummy data
            const count = MAX_TRAIL_LENGTH * 2;
            const geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(count * 3);
            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            
            const material = new THREE.MeshBasicMaterial({ 
                color: CONFIG.trailColor, 
                side: THREE.DoubleSide,
                transparent: true,
                opacity: 0.6,
                blending: THREE.AdditiveBlending
            });

            trailMesh = new THREE.Mesh(geometry, material);
            scene.add(trailMesh);
        }

        function createSpeedPad() {
            const geo = new THREE.BoxGeometry(4, 0.1, 6);
            const mat = new THREE.MeshBasicMaterial({ color: CONFIG.boostColor });
            const pad = new THREE.Mesh(geo, mat);
            
            // Random position
            pad.position.x = (Math.random() - 0.5) * 400;
            pad.position.z = (Math.random() - 0.5) * 400;
            pad.position.y = 0.05;
            
            scene.add(pad);
            speedPads.push(pad);
        }

        function setupInputs() {
            // Keyboard
            document.addEventListener('keydown', (e) => {
                if (e.key === 'ArrowUp' || e.key === 'w') input.y = 1;
                if (e.key === 'ArrowDown' || e.key === 's') input.y = -1;
                if (e.key === 'ArrowLeft' || e.key === 'a') input.x = 1; // Left
                if (e.key === 'ArrowRight' || e.key === 'd') input.x = -1; // Right
            });
            document.addEventListener('keyup', (e) => {
                if (['ArrowUp', 'w', 'ArrowDown', 's'].includes(e.key)) input.y = 0;
                if (['ArrowLeft', 'a', 'ArrowRight', 'd'].includes(e.key)) input.x = 0;
            });

            // Mobile Joystick
            if (isMobile) {
                const zone = document.getElementById('zone_joystick');
                zone.style.display = 'block';
                const manager = nipplejs.create({
                    zone: zone,
                    mode: 'static',
                    position: { left: '50%', top: '50%' },
                    color: '#00ffff'
                });

                manager.on('move', (evt, data) => {
                    const forward = Math.sin(data.angle.radian);
                    const turn = Math.cos(data.angle.radian);
                    input.y = forward;
                    input.x = -turn; // Invert for steering
                });
                manager.on('end', () => {
                    input.x = 0;
                    input.y = 0;
                });
            }
        }

        // --- Physics & Logic ---
        function updatePhysics() {
            if (!player) return;

            // Acceleration
            if (input.y > 0) currentSpeed += CONFIG.acceleration;
            else if (input.y < 0) currentSpeed -= CONFIG.acceleration;
            
            // Friction
            currentSpeed *= CONFIG.friction;
            
            // Cap speed (allow overspeed if boosted)
            if (currentSpeed > CONFIG.maxSpeed && currentSpeed < CONFIG.boostSpeed) {
                currentSpeed = Math.max(CONFIG.maxSpeed, currentSpeed * 0.99); 
            }

            // Turning (Drift mechanic: rotate player faster than velocity vector updates)
            if (Math.abs(currentSpeed) > 0.1) {
                player.rotation.y += input.x * CONFIG.turnSpeed;
                
                // Lean into turn
                player.rotation.z = -input.x * 0.3 * (Math.abs(currentSpeed)/CONFIG.maxSpeed);
            } else {
                player.rotation.z *= 0.9; // Straighten up
            }

            // Velocity Calculation
            const forwardDir = new THREE.Vector3(0, 0, 1).applyAxisAngle(new THREE.Vector3(0, 1, 0), player.rotation.y);
            
            // Drift logic: Mix current velocity with new forward direction
            // High drift factor = sticky, Low = icy
            velocity.x = velocity.x * CONFIG.driftFactor + forwardDir.x * currentSpeed * (1 - CONFIG.driftFactor);
            velocity.z = velocity.z * CONFIG.driftFactor + forwardDir.z * currentSpeed * (1 - CONFIG.driftFactor);

            // Apply Move
            player.position.add(velocity);

            // Speed Pad Collision
            checkCollisions();

            // Audio Pitch
            audio.updateEngine(Math.abs(currentSpeed) / CONFIG.maxSpeed);

            // HUD
            hudSpeed.innerText = Math.floor(Math.abs(currentSpeed) * 100);
        }

        function checkCollisions() {
            const pBox = new THREE.Box3().setFromObject(player);
            speedPads.forEach(pad => {
                const padBox = new THREE.Box3().setFromObject(pad);
                if (pBox.intersectsBox(padBox)) {
                    // Boost!
                    const boostVec = new THREE.Vector3(0,0,1).applyAxisAngle(new THREE.Vector3(0,1,0), player.rotation.y);
                    currentSpeed = CONFIG.boostSpeed;
                    
                    // UI Feedback
                    boostMsg.style.display = 'block';
                    setTimeout(() => boostMsg.style.display = 'none', 1000);
                    
                    // Sound
                    audio.playBoost();

                    // Move pad to new random location so we can hit it again
                    pad.position.x = (Math.random() - 0.5) * 400;
                    pad.position.z = (Math.random() - 0.5) * 400;
                }
            });
        }

        function updateCamera() {
            // Smooth follow
            const relativeOffset = new THREE.Vector3(0, 3, -8); // Behind and up
            const cameraOffset = relativeOffset.applyMatrix4(player.matrixWorld);
            
            camera.position.lerp(cameraOffset, 0.1);
            camera.lookAt(player.position);
        }

        function updateTrail() {
            // Add current point
            // We store two points per frame: Top of wall and Bottom of wall
            const left = new THREE.Vector3(-0.4, 0, 0).applyAxisAngle(new THREE.Vector3(0,1,0), player.rotation.y).add(player.position);
            const right = new THREE.Vector3(0.4, 0, 0).applyAxisAngle(new THREE.Vector3(0,1,0), player.rotation.y).add(player.position);

            trailPoints.push({
                top: new THREE.Vector3(player.position.x, 1.2, player.position.z),
                bottom: new THREE.Vector3(player.position.x, 0.1, player.position.z)
            });

            if (trailPoints.length > MAX_TRAIL_LENGTH) {
                trailPoints.shift();
            }

            // Update Geometry
            const positions = trailMesh.geometry.attributes.position.array;
            let idx = 0;
            // Loop backwards (newest to oldest) or forwards. 
            // We need to fill the buffer.
            for (let i = 0; i < MAX_TRAIL_LENGTH; i++) {
                if (i < trailPoints.length) {
                    const p = trailPoints[trailPoints.length - 1 - i];
                    // Vertex 1 (Top)
                    positions[idx++] = p.top.x;
                    positions[idx++] = p.top.y;
                    positions[idx++] = p.top.z;
                    // Vertex 2 (Bottom)
                    positions[idx++] = p.bottom.x;
                    positions[idx++] = p.bottom.y;
                    positions[idx++] = p.bottom.z;
                } else {
                    // Collapse unused vertices to player pos
                    positions[idx++] = player.position.x;
                    positions[idx++] = player.position.y;
                    positions[idx++] = player.position.z;
                    positions[idx++] = player.position.x;
                    positions[idx++] = player.position.y;
                    positions[idx++] = player.position.z;
                }
            }
            trailMesh.geometry.attributes.position.needsUpdate = true;
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            updatePhysics();
            updateTrail();
            updateCamera();
            composer.render();
        }

        // Start Button Logic
        document.getElementById('start-btn').addEventListener('click', () => {
            document.getElementById('start-screen').style.display = 'none';
            audio.init();
            init();
        });

    </script>
</body>
</html>
